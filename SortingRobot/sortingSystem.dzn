import interfaces.dzn;
import blockingSystem.dzn;
import beltSystem.dzn;
import ITimer.dzn;

interface ISorter {
	in void start();
	in void stop();
	out void error();
	
	enum State {Running, Stopped, Error};
	
	behaviour {
		State state = State.Stopped;
		
		[state.Stopped] {
			on start: {state = State.Running;}
			on stop: illegal;
		}
		[state.Running] {
			on start: illegal;
			on stop: {state = State.Stopped;}
			on optional: {error; state = State.Error;}
		}
		[state.Error] {
			on start: illegal;
			on stop: {state = State.Stopped;}
		}
	}
}

component SortingSystem {
	provides ISorter sortingSystem;
	
	system {
		Sorter sorter;
		DiskDetector diskDetector; 
		ColorSensor colorSensor;
		Belt belt;
		Blocker blocker;
		Timer timer;
		
		sortingSystem <=> sorter.sorter;
		sorter.diskDetector <=> diskDetector.sensor;
		sorter.colorSensor <=> colorSensor.colorSensor;
		sorter.belt <=> belt.belt;
		sorter.blocker <=> blocker.blocker;
		sorter.colorTimer <=> timer.iTimer;
	}
}

component Sorter {
	provides ISorter sorter;
	
	requires IBasicSensor diskDetector;	
	requires IColorSensor colorSensor;
	requires IBelt belt;
	requires IBlocker blocker;
	//requires ITimer detectorTimer;
	requires ITimer colorTimer;
	
	
	behaviour { // NOTE: All time is in MILLISECONDS
		IBlocker.unsigned_integer extendTime = $5000$; // Time it takes to PUSH disk into container
		IBlocker.unsigned_integer timeoutTime = $2500$; // Timeout time for piston. If piston does not extend in timeout time, ERROR
		ITimer.unsigned_integer diskScanInterval = $5000$; // Time it takes to SCAN disk
		//ITimer.unsigned_integer diskTime = $500$;
		//subint diskQueue {0..5}; // I highly doubt you can fit 5 disks between the two sensors...
		//diskQueue queue = 0;
		ISorter.State state = ISorter.State.Stopped;
		
		[state.Stopped] {
			on sorter.start(): {
				diskDetector.activate();
				belt.start();
				state = ISorter.State.Running;
			}
			on sorter.stop(): illegal;
			on blocker.error(), belt.error(): {
				// TODO: Consider if this needs an implementation...
			}
		}
		[state.Running] {
			on sorter.stop(): {
				diskDetector.deactivate();
				colorSensor.deactivate();
				belt.stop();
				colorTimer.cancel();
				state = ISorter.State.Stopped;
			}
			
			on diskDetector.triggered(): {
				//detectorTimer.start(diskTime);
				//queue = queue + 1;
				colorTimer.start(diskScanInterval);
				colorSensor.activate();
			}
			
			//on detectorTimer.timeout(): { // Time between disk detection of first disk to the time of the start of the second disk
				//diskSensor.deactivate();
				//diskSensor.activate();
			//}
			
			on colorTimer.timeout(): {
				// TODO: Consider if color sensor did not activate when there was a potential disk detected...
				colorSensor.deactivate();
			}
			
			on colorSensor.darkDisk(): {
				//[queue == 0] {
					// TODO: Consider if color sensor was activated without any disks detected...
				//}
				//[queue != 0] {
					//blocker.trigger(extendTime, timeoutTime);
					//queue = queue - 1;
				//}
			}
			
			on colorSensor.lightDisk(): { // Do nothing if light disk?
				//[queue == 0] {
					// TODO: Consider if color sensor was activated without any disks detected...
				//}
				//[queue != 0] {
					blocker.trigger(extendTime, timeoutTime);
					//queue = queue - 1;
				//}
			}
			
			on blocker.error(), belt.error(): {
				diskDetector.deactivate();
				colorSensor.deactivate();
				belt.stop();
				blocker.stop();
				colorTimer.cancel();
				state = ISorter.State.Error;
			}
			
			on sorter.start(): illegal;
		}
		[state.Error] {
			on sorter.start(): illegal;
			on sorter.stop(): {
				state = ISorter.State.Stopped;
			}
			on blocker.error(), belt.error(): {}
		}
	}
}

component ColorSensor {
	provides IColorSensor colorSensor;
	// Manual implementation in C++
}
