import interfaces.dzn;
import blockingSystem.dzn;

interface ITaking {
	in void start();
	in void stop();
	out void error();
	
	enum State {Running, Stopped, Error};
	
	behaviour {
		State state = State.Stopped;
		
		[state.Stopped] {
			on start: {state = State.Running;}
			on stop: illegal;
		}
		[state.Running] {
			on start: illegal;
			on stop: {state = State.Stopped;}
			on optional: {error; state = State.Error;}
		}
		[state.Error] {
			on start: illegal;
			on stop: {state = State.Stopped;}
		}
	}
}

component TakingSystem {
	provides ITaking takingSystem;
	
	system {
		Taker taker;
		DiskDetector detector;
		Blocker blocker;
		
		takingSystem <=> taker.taker;
		taker.diskDetector <=> detector.sensor;
		taker.blocker <=> blocker.blocker;
	}
}

component Taker {
	provides ITaking taker;
	
	requires IBlocker blocker;
	requires IBasicSensor diskDetector;
	
	behaviour {
		IBlocker.unsigned_integer extendTime = $2500$;
		IBlocker.unsigned_integer timeoutTime = $10000$;
		ITaking.State state = ITaking.State.Stopped;
		
		[state.Stopped] {
			on taker.start(): {
				diskDetector.activate();
				state = ITaking.State.Running;
			}
			on taker.stop(): illegal;
			on blocker.error(): {}
		}
		[state.Running] {
			on taker.start(): illegal;
			on taker.stop(): {
				blocker.stop();
				diskDetector.deactivate();
				state = ITaking.State.Stopped;
			}
			on blocker.error(): {
				state = ITaking.State.Error;
				taker.error();
				diskDetector.deactivate();
			}
			on diskDetector.triggered(): {
				blocker.trigger(extendTime, timeoutTime);
				diskDetector.activate();
			}
		}
		[state.Error] {
			on taker.start(): illegal;
			on taker.stop(): {state = ITaking.State.Stopped;}
			on blocker.error(): {}
		}
	}
}