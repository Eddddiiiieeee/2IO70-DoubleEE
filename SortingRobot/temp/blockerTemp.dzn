import blockingSystem.dzn;

// BLOCKING CONTROLLER TEMP
// BlockerController1 has sensor trigger on the top of the pistion extension
// BlockerController2 has sensor trigger when going down with piston

component BlockerController2 {
	provides IBlocker controller;
	
	requires IPiston piston;
	requires IBasicSensor sensor;
	requires ITimer pistonTimer;
	requires ITimer timeout;
	
	behaviour {
		//ITimer.unsigned_integer extendTime = $2500$;
		//ITimer.unsigned_integer timeoutTime = $10000$;
		bool pistonExtended = false;
		enum State {Retracted, Extended, Error};
		State state = State.Retracted;
		
		[state.Retracted] {
			on controller.trigger(extendTime, timeoutTime): {		
				sensor.activate();		
				pistonTimer.start(extendTime); // Time piston is extended
				timeout.start(timeoutTime); // Timer if sensor does not detect piston is up
				piston.extend();
				//pistonExtended = !pistonExtended;
				state = State.Extended;
			}
			
			on controller.stop(), timeout.timeout(), sensor.triggered(): {}
		}
		
		[state.Extended] {
			on controller.trigger(extendTime, timeoutTime): {
				[pistonExtended] {
					pistonTimer.cancel();
					//timeout.cancel();
					pistonTimer.start(extendTime);
				}
				[!pistonExtended] { // If piston has not reached the sensor, extend timer, give it another chance to trigger it
					pistonTimer.cancel();
					timeout.cancel();
					sensor.deactivate();
					
					pistonTimer.start(extendTime);
					timeout.start(timeoutTime);
					
					sensor.activate();
					//piston.extend();
				}
			}
			
			on controller.stop(): {
				piston.retract();
				pistonExtended = false;
				pistonTimer.cancel();
				timeout.cancel();
				sensor.deactivate();
				state = State.Retracted;
			}
			
			on pistonTimer.timeout(): {
				[pistonExtended] {
					piston.retract();
					pistonExtended = !pistonExtended;
					state = State.Retracted;
				} 
				[!pistonExtended] {
					controller.error();
					timeout.cancel();
					pistonTimer.cancel();
					sensor.deactivate();
					piston.retract();
					state = State.Error;
				}
			}
			
			on sensor.triggered(): {
				pistonExtended = true;
				timeout.cancel();
			}
			
			on timeout.timeout(): {
				controller.error();
				pistonTimer.cancel();
				sensor.deactivate();
				piston.retract();
				state = State.Error;
			}
		}
		
		[state.Error] {
			on controller.stop(): {
				[!pistonExtended] {
					state = State.Retracted;
				}
				[pistonExtended] {
					piston.retract();
					pistonExtended = !pistonExtended;
					state = State.Retracted;
				}
			}
			on controller.trigger(extendTime, timeoutTime), sensor.triggered(): {}
		}
	}
}

component BlockerController1 {
	provides IBlocker controller;
	
	requires IPiston piston;
	requires IBasicSensor sensor;
	requires ITimer pistonTimer;
	requires ITimer timeout;
	
	behaviour {
		//ITimer.unsigned_integer extendTime = $2500$;
		//ITimer.unsigned_integer timeoutTime = $10000$;
		bool pistonExtended = false;
		enum State {Retracted, Extended, Error};
		State state = State.Retracted;
		
		[state.Retracted] {
			on controller.trigger(extendTime, timeoutTime): {
				// After 'stop' in the 'Extended' state, the system waits for the sensor
				// to be triggered. If we want to trigger this when the piston is going up,
				// we must cancel both timers and reactivate the sensor.
				pistonTimer.cancel(); 
				timeout.cancel();
				sensor.deactivate();
				
				piston.extend();
				sensor.activate();
				pistonTimer.start(extendTime); // Time piston is extended
				timeout.start(timeoutTime); // Timer if sensor does not detect piston is up
				pistonExtended = !pistonExtended;
				state = State.Extended;
			}
			
			on timeout.timeout(): {
				controller.error();
				state = State.Error;
			}
			
			on sensor.triggered(): {
				[!pistonExtended] {
					timeout.cancel();
				}
				[pistonExtended] {
					controller.error();
					timeout.cancel();
					pistonTimer.cancel();
					state = State.Error;
				}
			}
			on controller.stop(): {
				[!pistonExtended] {
					
				}
				[pistonExtended] {
					
				}
			}
		}
		
		[state.Extended] {
			on controller.trigger(extendTime, timeoutTime): {
				[!pistonExtended] {
					// pistonTimer retracts piston and 'trigger' was called
					// in between the piston retraction and sensor activation.
					// So, during this time, the piston is supposed to be on 
					// its way up, so:
					piston.extend();
					pistonExtended = !pistonExtended;
					pistonTimer.cancel();
					timeout.cancel();
					pistonTimer.start(extendTime);
					timeout.start(timeoutTime);
				}
				[pistonExtended] {
					pistonTimer.cancel();
					timeout.cancel();
					pistonTimer.start(extendTime);
					timeout.start(timeoutTime);
				}
			}
			
			on controller.stop(): {
				[!pistonExtended] {
					// pistonTimer retracts piston and 'stop' was called
					// when piston is going up and sensor is not activated
					// SO, cancel the pistonTimer (not necessary but whatever),
					// deactivate the sensor and set the state as 'Retracted', 
					// BUT: we wait for the timeout in the 'Retracted' state.
					
					pistonTimer.cancel();
					//sensor.deactivate();
					state = State.Retracted;
				}
				[pistonExtended] {
					piston.retract();
					pistonExtended = !pistonExtended;
					pistonTimer.cancel();
					//timeout.cancel();
					//sensor.deactivate();
					state = State.Retracted;
				}
			}
			
			on pistonTimer.timeout(): {
				piston.retract();
				pistonExtended = !pistonExtended;
			}
			
			on sensor.triggered(): {
				[!pistonExtended] {
					timeout.cancel();
					state = State.Retracted;
				}
				[pistonExtended] { // How can the piston be extended before the sensor was triggered??? ERROR!
					controller.error();
					timeout.cancel();
					pistonTimer.cancel();
					state = State.Error;
				}
			}
			
			on timeout.timeout(): {
				controller.error();
				pistonTimer.cancel();
				sensor.deactivate();
				state = State.Error;
			}
		}
		
		[state.Error] {
			on controller.stop(): {
				[!pistonExtended] {
					state = State.Retracted;
				}
				[pistonExtended] {
					piston.retract();
					pistonExtended = !pistonExtended;
					state = State.Retracted;
				}
			}
			on controller.trigger(extendTime, timeoutTime), sensor.triggered(): {}
		}
	}
}