import sortingSystem.dzn;
import takingSystem.dzn;
import returnSystem.dzn;
import IRobotCommunication.dzn;
import ITimer.dzn;

component Robot {
	provides IRobotCommunication robot;
	
	system {
		RaspberryPi controller;
		SortingSystem sorter;
		TakingSystem taker;
		ReturningSystem returner;
		Timer heartbeatClock;
		
		robot <=> controller.controller;
		controller.sorting <=> sorter.sortingSystem;
		controller.taker <=> taker.takingSystem;
		controller.returner <=> returner.returningSystem;
		controller.heartbeatClock <=> heartbeatClock.iTimer;
	}
}

component RaspberryPi {
	provides IRobotCommunication controller;
	
	requires ISorter sorting;
	requires ITaking taker;
	requires IReturner returner;
	requires ITimer heartbeatClock;
	
	behaviour {
		enum State {Idle, Running};
		State state = State.Idle;
		
		on controller.respondDiskCounters(), 
		   controller.respondDisksTaken(),
		   controller.error_in(),
		   controller.heartbeat1(),
		   controller.heartbeat2(),
		   controller.heartbeat3(),
		   controller.heartbeat4(),
		   controller.tookDisk_in(): {}
		
		[state.Idle] {
			on controller.start(): {
				state = State.Running;
				sorting.start();
				taker.start();
				returner.start();
				heartbeatClock.start($5000$); // 5 second heartbeat
			}
			on controller.stop(): illegal;
			on controller.emergencyStop(): {}
		}
		[state.Running] {
			on controller.stop(), controller.emergencyStop(): {
				state = State.Idle;
				sorting.stop();
				taker.stop();
				returner.stop();
				heartbeatClock.cancel();
			}
			
			on sorting.error(), taker.error(), returner.error(): {
				state = State.Idle; // TODO: WORK ON ERROR CODES AND SEVERITY OF IT SO WE DON'T STOP THE WHOLE FACTORY
				controller.emergency();
				sorting.stop();
				taker.stop();
				returner.stop();
				heartbeatClock.cancel();
			}
			
			on heartbeatClock.timeout(): {
				heartbeatClock.start($5000$);
				controller.heartbeat();
			}
			
			on controller.start(): illegal;
		}
	}
}