import interfaces.dzn;
import ITimer.dzn;

/**
 * @pram extendTime		Time in (ms) for the piston to be extended
 * @pram timeoutTime	Time in (ms) for how long before we declare ERROR if the piston does not extend
 * @throws error() if timeoutTime has passed and the piston did not extend (sensor reading)
 */
interface IBlocker {
	extern unsigned_integer $unsigned int$;
	in void trigger(unsigned_integer extendTime, unsigned_integer timeoutTime);	
	in void stop();
	out void error();
	
	behaviour {
		enum State {Retracted, Extended, Error};
		State state = State.Retracted;
		
		[state.Retracted] {
			on trigger: state = State.Extended;
			on stop: {}
			on optional: {error; state = State.Error;}
		}
		
		[state.Extended] {
			on trigger: {}
			on stop: state = State.Retracted;
			on optional: {error; state = State.Error;}
		}
		[state.Error] {
			on trigger: {}
			on stop: state = State.Retracted;
		}
	}
}

component Blocker {
	provides IBlocker blocker;
	
	system {
		BlockerController controller;
		Piston piston;
		Button button;
		Timer pistonTimer;
		Timer timeoutTimer;
		
		blocker <=> controller.controller;
		controller.piston <=> piston.piston;
		controller.sensor <=> button.sensor;
		controller.pistonTimer <=> pistonTimer.iTimer;
		controller.timeout <=> timeoutTimer.iTimer;
	}
}

component BlockerController {
	provides IBlocker controller;
	
	requires IPiston piston;
	requires IBasicSensor sensor;
	requires ITimer pistonTimer;
	requires ITimer timeout;
	
	behaviour {
		//ITimer.unsigned_integer extendTime = $2500$;
		//ITimer.unsigned_integer timeoutTime = $10000$;
		bool pistonExtended = false;
		enum State {Retracted, Extended, Error};
		State state = State.Retracted;
		
		[state.Retracted] {
			on controller.trigger(extendTime, timeoutTime): {		
				sensor.activate();		
				pistonTimer.start(extendTime); // Time piston is extended
				timeout.start(timeoutTime); // Timer if sensor does not detect piston is up
				piston.extend();
				//pistonExtended = !pistonExtended;
				state = State.Extended;
			}
			
			on controller.stop(), timeout.timeout(), sensor.triggered(): {}
		}
		
		[state.Extended] {
			on controller.trigger(extendTime, timeoutTime): {
				[pistonExtended] {
					pistonTimer.cancel();
					//timeout.cancel();
					pistonTimer.start(extendTime);
				}
				[!pistonExtended] { // If piston has not reached the sensor, extend timer, give it another chance to trigger it
					pistonTimer.cancel();
					timeout.cancel();
					sensor.deactivate();
					
					pistonTimer.start(extendTime);
					timeout.start(timeoutTime);
					
					sensor.activate();
					//piston.extend();
				}
			}
			
			on controller.stop(): {
				piston.retract();
				pistonExtended = false;
				pistonTimer.cancel();
				timeout.cancel();
				sensor.deactivate();
				state = State.Retracted;
			}
			
			on pistonTimer.timeout(): {
				[pistonExtended] {
					piston.retract();
					pistonExtended = !pistonExtended;
					state = State.Retracted;
				} 
				[!pistonExtended] {
					controller.error();
					timeout.cancel();
					pistonTimer.cancel();
					sensor.deactivate();
					piston.retract();
					state = State.Error;
				}
			}
			
			on sensor.triggered(): {
				pistonExtended = true;
				timeout.cancel();
			}
			
			on timeout.timeout(): {
				controller.error();
				pistonTimer.cancel();
				sensor.deactivate();
				piston.retract();
				state = State.Error;
			}
		}
		
		[state.Error] {
			on controller.stop(): {
				[!pistonExtended] {
					state = State.Retracted;
				}
				[pistonExtended] {
					piston.retract();
					pistonExtended = !pistonExtended;
					state = State.Retracted;
				}
			}
			on controller.trigger(extendTime, timeoutTime), sensor.triggered(): {}
		}
	}
}


component Piston {
	provides IPiston piston;
	
	behaviour {
		IPiston.State state = IPiston.State.Retracted;
		
		[state.Retracted] {
			on piston.extend(): {state = IPiston.State.Extended;}
			on piston.retract(): illegal;
		}
		[state.Extended] {
			on piston.extend(): illegal;
			on piston.retract(): {state = IPiston.State.Retracted;}
		}
	}
}